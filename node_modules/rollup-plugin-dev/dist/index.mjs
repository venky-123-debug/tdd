import Joi from 'joi';
import fp from 'fastify-plugin';
import ms from 'ms';
import { blue, bold, yellow, dim, green, red, cyan } from 'femtocolor';
import Fastify from 'fastify';
import proxyPlugin from '@fastify/http-proxy';
import staticPlugin from '@fastify/static';
import { resolve } from 'path';
import timing from 'fastify-request-timing';
import getPort, { makeRange } from 'get-port';

// this is a modified version of https://github.com/sindresorhus/date-time
// but they don't provide a CJS build
function dateTime() {
  let date = new Date();
  let end = '';

  // Offset the date so it will return the correct value when getting the ISO string.
  date = new Date(date.getTime() - (date.getTimezoneOffset() * 60000));

  return date
    .toISOString()
    .replace(/T/, ' ')
    .replace(/\..+/, end)
}

const EOL = '\n';
const colorCodes = { 5: red, 4: yellow, 3: cyan, 2: green };
const getColor = status => colorCodes[Math.trunc(status / 100)];

const responseLogger = fp(async server => {
  const logResponse = async (req, reply) => {
    const status = reply.statusCode;
    const c = getColor(status);
    const timing = ms(parseInt(reply.getResponseTime())) || '';
    server.log.info(bold(c(req.method)) + ' ' + req.url + c(' • ') + dim(status + ' • ' + timing));
  };
  server.addHook('onResponse', logResponse);
});


const header = blue('⚡︎dev-server');

const prettifier = () => entry => {
  if (entry.reqId) return
  if (entry.msg) {
    if (entry.msg.includes('Server listening')) {
      const startup = entry.msg.replace('Server listening', header).split('at');
      entry.msg = startup[0] + 'listening on' + bold(green(startup[1]));
    }
    const output = [];
    output.push(`[${dateTime()}]`, entry.msg);
    return output.join(' ') + EOL
  }
};

const logDir = (server) => (dir) => server.log.info(header + ' serving ' + bold(dir));
const logSpa = (server, spaFile) => server.log.info(header + ' using fallback file ' + bold(spaFile));
const logProxy = (server, from, to) => server.log.info(header + ' proxying from ' + bold(yellow(from)) + ' to ' + bold(yellow(to)));

const proxyItem = Joi.object({
  from: Joi.string().uri({ relativeOnly: true }),
  to: Joi.string().uri(),
  opts: Joi.object()
});

const schema = Joi.alternatives().try(
  Joi.string(),
  Joi.object({
    silent: Joi.boolean(),
    force: Joi.boolean(),
    proxy: Joi.array().items(proxyItem),
    dirs: Joi.array().items(Joi.string()),
    dirname: Joi.string(),
    spa: [Joi.boolean(), Joi.string()],
    port: Joi.number().port(),
    host: [Joi.string().ip(), Joi.string().hostname()],
    basePath: Joi.string().uri({ relativeOnly: true }),
    extend: Joi.function(),
    server: Joi.object(),
    onListen: Joi.function()
  })
);

const serverDefaults = Object.freeze({
  ignoreTrailingSlash: true,
  disableRequestLogging: true
});

const pluginServer = Object.freeze({
  logger: { prettyPrint: { suppressFlushSyncWarning: true }, prettifier }
});

const defaults = {
  proxy: [],
  dirs: ['.'],
  port: 8080,
  host: 'localhost',
  spa: false,
  silent: false,
  force: false,
  server: {
    ...pluginServer,
    ...serverDefaults
  },
  basePath: undefined,
  extend: undefined,
  dirname: undefined,
  onListen: undefined
};

const normalize = (rollupOptions = {}) => {
  const parsed = Joi.attempt(rollupOptions, schema);
  const normalized = (typeof parsed === 'string') ? { dirs: [parsed] } : parsed;
  const serverConfig = Object.assign({}, defaults.server, normalized.server);
  const config = Object.assign({}, defaults, normalized);
  config.server = serverConfig;
  if (config.silent) config.server.logger = false;
  return config
};

const createProxy = (server) => ({ from, to, opts }) => {
  logProxy(server, from, to);
  const prefix = from.endsWith('/') ? from.slice(0, -1) : from;
  const url = new URL(to);
  const upstream = url.origin;
  const rewritePrefix = url.pathname;
  server.register(proxyPlugin, {
    prefix,
    upstream,
    rewritePrefix,
    undici: false,
    ...opts
  });
};

var proxy = fp(async (server, { proxy = [] }) => proxy.forEach(createProxy(server)));

var dirs = fp(async (server, { basePath, dirs, dirname = '' }) => {
  const prefix = basePath;
  const root = dirs.map(dir => resolve(dirname, dir));
  root.forEach(logDir(server));

  server.register(staticPlugin, { prefix, root });
});

var spa = fp(async (server, { spa }) => {
  if (!spa) return
  const fallbackFile = (typeof spa === 'boolean') ? 'index.html' : spa;
  logSpa(server, fallbackFile);
  const spaHandler = async (_, reply) => reply.sendFile(fallbackFile);
  server.setNotFoundHandler(spaHandler);
});

async function init(config = {}) {
  const server = Fastify(config.server);
  await server.register(proxy, config);
  await server.register(dirs, config);
  await server.register(spa, { ...config, prefix: config.basePath });
  await server.register(timing);
  await server.register(responseLogger);
  if (config.extend) await server.register(config.extend, config);
  await server.ready();

  return server
}

async function boot(config) {
  try {
    const resolvedPort = await getPort({ host: (config.host ?? '127.0.0.0'), port: [config.port, ...makeRange(8081, 9000)] });
    const server = await init(config);
    await server.listen(resolvedPort, config.host);
    if (config.onListen) config.onListen(server);
  } catch (err) {
    console.error(err);
  }
}

var index = (opts = {}) => {
  let booted = false;
  return {
    name: 'dev-server',
    async writeBundle() {
      if (booted) return
      booted = true;
      try {
        const config = normalize(opts);
        if (!this.meta.watchMode) {
          if (!config.force) return
          else this.warn(`Starting dev-server even though we're not in watch mode`);
        }
        await boot(config);
      } catch (err) {
        this.error(err);
      }
    }
  }
};

export { index as default };
